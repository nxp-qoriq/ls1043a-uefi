/** @QspiDxe.c

  Driver for installing BlockIo protocol over QSPI

  Based on i2c implementation available in MdeModulePkg/Bus/I2c/I2cDxe/I2cBus.c

  Copyright (c) 2013 - 2014, Intel Corporation. All rights reserved.
  Copyright (c) 2016, Freescale Semiconductor, Inc. All rights reserved.

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD
  License which accompanies this distribution. The full text of the license
  may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#include <Library/Qspi.h>

EFI_BLOCK_IO_MEDIA gQspiMedia = {
  SIGNATURE_32('d', 's', 'p', 'i'),         // MediaId
  FALSE,                                    // RemovableMedia
  TRUE,                                     // MediaPresent
  FALSE,                                    // LogicalPartition
  FALSE,                                    // ReadOnly
  FALSE,                                    // WriteCaching
  0,                                        // BlockSize
  2,                                        // IoAlign
  0,                                        // Pad
  0                                         // LastBlock
};

// Device path for SemiHosting. It contains our autogenerated Caller ID GUID.
typedef struct {

  VENDOR_DEVICE_PATH        Guid;

  EFI_DEVICE_PATH_PROTOCOL  End;

  } FLASH_DEVICE_PATH;

FLASH_DEVICE_PATH gDevicePath = {
    {
      { HARDWARE_DEVICE_PATH, HW_VENDOR_DP,
        { sizeof (VENDOR_DEVICE_PATH), 0 } 
      },
      EFI_CALLER_ID_GUID
    },
    { END_DEVICE_PATH_TYPE,
      END_ENTIRE_DEVICE_PATH_SUBTYPE,
      { sizeof (EFI_DEVICE_PATH_PROTOCOL), 0}
    }
  };

EFI_EVENT EfiExitBootServicesEvent      = (EFI_EVENT)NULL;

EFI_STATUS
EFIAPI
QspiReset (
  IN EFI_BLOCK_IO_PROTOCOL          *This,
  IN BOOLEAN                        ExtendedVerification
  )
{
  return EFI_SUCCESS;
}

EFI_STATUS
EFIAPI
QspiReadBlocks (
  IN EFI_BLOCK_IO_PROTOCOL          *This,
  IN UINT32                         MediaId,
  IN EFI_LBA                        Lba,
  IN UINTN                          BufferSize,
  OUT VOID                          *Buffer
  )
{
  return QspiRead(This, MediaId, Lba, BufferSize, Buffer);
}

EFI_STATUS
EFIAPI
QspiWriteBlocks (
  IN EFI_BLOCK_IO_PROTOCOL          *This,
  IN UINT32                         MediaId,
  IN EFI_LBA                        Lba,
  IN UINTN                          BufferSize,
  IN VOID                           *Buffer
  )
{
  EFI_STATUS Status = EFI_SUCCESS;

  Status = QspiErase(This, MediaId, Lba, BufferSize);
  if (Status != EFI_SUCCESS)
    return Status;

  return QspiWrite(This, MediaId, Lba, BufferSize, Buffer);
}

EFI_STATUS
EFIAPI
QspiFlushBlocks (
  IN EFI_BLOCK_IO_PROTOCOL  *This
  )
{
  return EFI_SUCCESS;
}

EFI_BLOCK_IO_PROTOCOL BlockIo =
{
  EFI_BLOCK_IO_INTERFACE_REVISION,	// Revision
  &gQspiMedia,			// *Media
  QspiReset,				// Reset
  QspiReadBlocks,			// ReadBlocks
  QspiWriteBlocks,			// WriteBlocks
  QspiFlushBlocks			// FlushBlocks
};

/**
  Shutdown our hardware

  @param[in]  Event   	The Event that is being processed
  @param[in]  Context 	Event Context
**/
VOID
EFIAPI
QspiExitBootServicesEvent (
  IN EFI_EVENT  Event,
  IN VOID       *Context
  )
{
  EFI_HANDLE			ImageHandle = NULL;
  QspiUnload(ImageHandle);
  QspiFlashFree();
}

VOID
QspiTest (
  VOID
  )
{
  EFI_STATUS Status;
  UINTN BufferSize = 0x10000;
  UINT8 DestinationBuffer[BufferSize];
  UINT8 SourceBuffer[BufferSize];
  UINTN Index = 0;
  UINT32 Lba = 0xA00000;

  for(Index = 0; Index < BufferSize; Index++) {
       if (Index % 2 == 0)
        SourceBuffer[Index] = 0x61;
      else
        SourceBuffer[Index] = 0x52;
  }

  Status = QspiErase(NULL, 0, Lba, BufferSize);
  if (Status != EFI_SUCCESS) {
    DEBUG((EFI_D_ERROR,"Failed to Erase QSPI\n"));
  }

  Status = QspiWrite(NULL, 0, Lba, BufferSize, SourceBuffer);
  if (Status != EFI_SUCCESS)
    DEBUG((EFI_D_ERROR,"Failed to Write on QSPI\n"));

  Status = QspiRead(NULL, 0, Lba, BufferSize, DestinationBuffer);
  if (Status != EFI_SUCCESS)
    DEBUG((EFI_D_ERROR,"Failed to Read from QSPI\n"));

  for (Index = 0; Index < BufferSize; Index++) {
    if (SourceBuffer[Index] != DestinationBuffer[Index]) {
        DEBUG((EFI_D_ERROR, "Qspi Flash Test Result: FAIL\n"));
        break;
    }
  }
  if (Index == BufferSize)
    DEBUG((EFI_D_ERROR, "Qspi Test Result: PASS\n"));
}

EFI_STATUS
QspiInitialize (
  IN EFI_HANDLE		ImageHandle,
  IN EFI_SYSTEM_TABLE	*SystemTable
  )
{
  EFI_STATUS              Status;

  Status = QspiInit(&gQspiMedia);
  if (Status != EFI_SUCCESS) {
    DEBUG((EFI_D_ERROR,"Failed to init QSPI\n"));
    return Status;
  }

  if (FeaturePcdGet(PcdQspiTest))
    QspiTest();

  //
  // Install driver model protocol(s).
  //
  Status = gBS->InstallMultipleProtocolInterfaces (
             &ImageHandle,
             &gEfiDevicePathProtocolGuid, &gDevicePath,
             &gEfiBlockIoProtocolGuid, &BlockIo,
	      NULL
             );

  // Register for an QspiExitBootServicesEvent
  Status = gBS->CreateEvent (EVT_SIGNAL_EXIT_BOOT_SERVICES, TPL_NOTIFY,
		QspiExitBootServicesEvent, NULL, &EfiExitBootServicesEvent);

  return Status;
}

/**
  This is the unload handle for Qspi Controller module.

  Disconnect the driver specified by ImageHandle from all the devices in the
  handle database.
  Uninstall all the protocols installed in the driver entry point.

  @param[in] ImageHandle           The drivers' driver image.

  @retval    EFI_SUCCESS           The image is unloaded.
  @retval    Others                Failed to unload the image.

**/
EFI_STATUS
EFIAPI
QspiUnload (
  IN EFI_HANDLE             ImageHandle
  )
{
  EFI_STATUS				Status;
  EFI_HANDLE				*DeviceHandleBuffer;
  UINTN				DeviceHandleCount;

  //
  // Get the list of all Qspi Controller handles in the handle database.
  // If there is an error getting the list, then the unload
  // operation fails.
  //
  Status = gBS->LocateHandleBuffer (
                  ByProtocol,
                  &gEfiBlockIoProtocolGuid,
                  NULL,
                  &DeviceHandleCount,
                  &DeviceHandleBuffer
                  );
  //
  // Free the buffer containing the list of handles from the handle database
  //
  if (DeviceHandleBuffer != NULL) {
    gBS->FreePool (DeviceHandleBuffer);
  }

  return Status;
}
